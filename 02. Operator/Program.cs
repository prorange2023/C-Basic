namespace _02._Operator
{
    internal class Program
    {
        static void Main(string[] args)
        {
            bool b = false;
            int i = 0;
            float f = 0.0f;

            /********************************************************************
             * 연산자 (Operator)
             *
             * 프로그래밍 언어에서는 일반적인 수학 연산과 유사한 연산자들이 지원됨
             * C##는 여러 연산자를 제공하며 기본 연산을 수행할 수 있음
             *********************************************************************/


            /**************************************************************
            * 산술 연산자
            **************************************************************/
            // < 이진연산자 >
            i = 2 + 3; //더하기 +
            i = 3 - 1; //빼기 -
            i = 3 * 3; //곱하기 *
            f = 5.0f / 2.0f; //나누기 / 주의사항: 5/2와 같이 int의 나눗셈은 소수점이 버려짐
            i = 13 % 3; //나머지 %

            // < 단항연산자 >
            i = +3;           // + 단항연산자(양수) : 사실상 값을 그대로 두는거라 무의미
            i = -3;           // - 단항연산자(음수) : 값을 마이너스로 변환 -> 2의 보수로 만든다는 말.
            i = -(-3); // 이럼 걍 +임
                    
            ++i; // ++ 전위 증가 연산자 : 값을 1 증가
            i++; // ++ 후위 증가 연산자 : 값을 1 증가            
            --i; // -- 전위 감소 연산자 : 값을 1 감소
            i--; // -- 후위 감소 연산자 : 값을 1 감소

            // < 전위연산자와 후위연산자 >
            // 전위연산자 : 더하고 값 연산
            // 예시상황

            i = 0;
            Console.WriteLine(i);   // output : 0
            Console.WriteLine(++i); // output : 1
            Console.WriteLine(i);   // output : 1
            // 후위연산자 : 값을 반환한 후에 연산
            i = 0;
            Console.WriteLine(i);   // output : 0
            Console.WriteLine(i++); // output : 0
            Console.WriteLine(i);   // output : 1

          /**************************************************************
           * 대입 연산자
           **************************************************************/

            i = 10;             // = 대입 연산자 : 오른쪽 값을 왼쪽 변수에 대입
                                // 플밍할때 같다는 == 기억해랑
           
            i += 10;

            // <복합 대입 연산자>
            // 이진 연산자(op)의 경우
            // x op= y 는 x = x op y 와 동일
            i += 5;        // i = i + 5; 와 동일 한마디로 축약

            i *= 2;         // i = i*2; 와 동일

            /****************************************************************
             * 비교 연산자
             ****************************************************************/

            // <비교 연산자>
            b = 3 > 1;     // >  : 왼쪽 피연산자가 더 클 경우 true, 아니면 false, bull 자료형에 저장 가능
            b = 3 < 1;     // <  : 왼쪽 피연산자가 더 작을 경우 true
            b = 3 >= 1;    // >= : 왼쪽 피연산자가 더 크거나 같은 경우 true
            b = 3 <= 1;    // <= : 왼쪽 피연산자가 더 작거나 같은 경우 true
            b = 3 == 1;    // == : 두 피연산자가 같은 경우 true
            b = 3 != 1;    // != : 두 피연산자가 다를 경우 true

          /****************************************************************
           * 논리 연산자
           ****************************************************************/
            // 스킬을 쓰려면 쿨타임이 안남아있어야하고 동시에 마나도 스킬 마나보다 높아야 가능
            // 점프조건 : 땅바닥에 붙어있거나 공중점프 템먹었으면
            // 승리조건 : 마피아 전부 잡거나 미션 전부 클리어하면
            // 이런 논리 연산방법임

            // <논리 연산자>
            b = !false;            // !(Not)(역)  : 피연산자의 논리 부정을 반환 == true -> false, false -> true로 변환
           
            b = true && false;     // &&(And) : 두 피연산자가 모두 true 일 경우 true
                                    
            // ex) true&&true 는 true, true&&false 는 false, false&&false는 false, false&&true 는 false
            
            b = true || false;     // ||(Or)  : 둘중 하나라도 true 면 true
                                   // 입력법이 shift + \(원화그림 있는곳)
                                   
            // ex 

            // true || true; // true
            // true || false; // true
            // false || true; // true
            // false || false; // false

            b = true ^ false;      // ^(Xor)  : 두 피연산자가 다를 경우 true
                                   // 이건 굳이 하지마


            // <조건부 논리 연산자>

            // 어몽어스 시민 승리 
            // 마피아를 모두 투표로 추방함 또는 미션을 모두 클리어했음
            // true || 어떤게 오더라도 무조건 true

            // true || x 이러면 뒤에 뭐가 오던 true 니까 바로 true 도출하고 뒤 데이터는 안봄
            // 예를 들어
            i = 10;
            b = true || (i++ > 5);
            // 위를 뒤집으면 또 바뀜. 이걸로 인해 버그 가능성 있겠네
            // 이런 가능성을 피하기 위해선 아랫줄에 따로 i++; 를 적어주던가 , 굳이 논리연산자안에 산술연산을 넣지 말던가
            Console.WriteLine(i);



            // 조건부 논리 And 연산자 &&
            // 빠른 계산을 위해 false && x(논리자료형) 의 경우 어떠한 논리자료형이 있어도
            // 결과는 항상 false이기 때문에 false && x 에서 x는 무시하게 됨
            i = 10;
            b = false && (i++ > 5);
            Console.WriteLine(i); //output : 10

            /****************************************************************
            * 비트 연산자 --> 미친듯이 빠른 연산법(다른거에 비해)
            ****************************************************************/

            // <단항 연산자>

            i = 0b00110110; // 앞에 0b 붙으면 이진수선언
            i = 0b0011;
            i = 0x1F;  // 앞에 0x 붙으면 16진수 선언 // ~(비트 보수) : 데이터를 비트단위로 보수 연산 ex) 1001 -> 0110

            // <이진 연산자>  &,|,^가 하나면 이진 두개면 논리, 사용률 매우낮으니 굳이 외우진 말고

            i = 0x11 & 0x83;   // &(And) : 데이터를 비트단위로 And 연산

            // 1101 & 1000; 이면 1000이 결과값

            i = 0x11 | 0x83;   // |(Or)  : 데이터를 비트단위로 Or 연산

            // 1101 | 1001; 이면 1001이 결과값

            i = 0x11 ^ 0x83;   // ^(Xor) : 데이터를 비트단위로 Xor 연산

            // 1101 ^ 1000; 이면 0010이 결과값.

            // <비트 쉬프트 연산자>

            i = 0x20 << 2;     // << : 왼쪽의 피연산자의 비트를 오른쪽 피연산자만큼 왼쪽으로 이동. 데이터를 비트 단위로 왼쪽으로 이동
            i = 0x20 >> 2;     // >> : 왼쪽의 피연산자의 비트를 오른쪽 피연산자만큼 오른쪽으로 이동. 데이터를 비트 단위로 오른쪽으로 이동

            // 이게 비트 단위로 계산 돌리는거라 빠르긴 엄청 빠르다고함...최적화때 쓰려나
            // 나누기보다 곱하기가 100배 빠르니까..100 / 2를 100 * 0.5 하는게 100배 빠름 / 이걸 더 하면 100 >> 1 이러면 10000배는 빠르다 이런 느낌
            // 0010 <<1 -> 0100으로 바뀜. 데이터를 비트 위로 왼쪽으로 한칸 민다 

            /****************************************************************
             * 연산자 우선순위 - > 큰 순서만 알아라 
             *
             * 여러 연산자가 있는 식에서 우선 순위가 높은 연산자가 먼저 계산
             ****************************************************************/

            // <연산자 우선순위>
            // 1. 기본 연산        : a[i], x++, x--
            // 2. 단항 연산        : +x, -x, !x, ~x, ++x, --x, (Type)x
            // 3. 곱하기 연산      : x * y, x / y, x % y
            // 4. 더하기 연산      : x + y, x - y
            // 5. 시프트 연산      : x << y, x >> y
            // 6. 비교 연산        : x < y, x > y, x <= y, x >= y
            // 7. 같음 연산        : x == y, x != y
            // 8. 논리 AND 연산    : x & y, x && y
            // 9. 논리 XOR 연산    : x ^ y
            // 10. 논리 OR 연산    : x | y, x || y
            // 11. 대입 연산       : x = y, x op= y

            // 대략 적인 순서 기본 > 곱하기 > 더하기 > 비교 > 논리 > 대입 이렇게 알고 있자
            // 우선순위 따지기 빡세면 괄호 활용하자
        }
    }
}